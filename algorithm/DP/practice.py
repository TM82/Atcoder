# 問題 1:　最大和問題
# n 個の整数 a[0],a[1],…,a[n−1] が与えられる。これらの整数から何個かの整数を選んで総和をとったときの、総和の最大値を求めよ。
# また、何も選ばない場合の総和は 0 であるものとする。

# 【制約】
# ・1≤n≤10000
# ・−1000≤a[i]≤1000

# 【数値例】
# 1) 
# 　n=3
# 　a=(7,−6,9)
# 　答え: 16 (7 と 9 を選べばよいです)

# 2)
# 　n = 2
# 　a=(−9,−16)
# 　答え: 0 (何も選ばないのがよいです)

# →正の値を全部足せばいいが、DPに慣れるためDPで解く

# dp[0] := 何も選ばない状態
# dp[1] := 0 番目までの整数 (a[0] のみ) の中から整数を選んで総和をとったときの、総和の最大値
# dp[2] := 1 番目までの整数 (a[0],a[1]) の中から整数を選んで総和をとったときの、総和の最大値
# …
# dp[i+1] := i 番目までの整数 (a[0],…,a[i]) の中から整数を選んで総和をとったときの、総和の最大値
# とします。
# 求める値は、dp[n] です。

# 既に dp[i] の値が求まっていることを前提に、dp[i+1] の値を求めることを考えます。
# dp[i] を使って dp[i+1] について考えるとき、a[0],a[1],…,a[i−1] のどれを選んだらよいかが既に決まっているので、a[i] を選ぶか選ばないかだけ決めればよいです。

# 選ぶとき　　: dp[i] に a[i] が加算されるので、dp[i+1]=dp[i]+a[i] です
# 選ばないとき: dp[i] は特に何も加算されないので、dp[i+1]=dp[i] です

# DP遷移式
#   dp[i+1] = max(dp[i],dp[i]+a[i])
# 初期条件
#   dp[0] = 0


n = int(input())
a = list(map(int,input().split()))
dp = []

dp.append(0)
for i in range(n):
    dp.append(max(dp[i],dp[i] + a[i]))

print(dp)